En esta sección se describen los pasos a seguir para completar la tarea, la cual consiste en desarrollar código en C++ <<\nameref{subsec:implementations}>> y en realizar un informe <<\nameref{subsec:report}>>. Se espera que cada uno de los pasos se realice de manera ordenada y siguiendo las instrucciones dadas.

\begin{mdframed}
    Abra este documento en algún lector de pdf que permita hipervínculos, ya que en este documento el texto en color \textcolor{blue}{azul} suele indicar un hipervínculo.
\end{mdframed}

\begin{enumerate}[(1)]
    \item 
    En caso de cualquier duda, contactarse directamente con \textbf{Pablo Álvarez}. Para esto pueden hacerlo por mensaje directo en discord (\url{pabloealvarez}) o correo electrónico (\url{pablo.alvarezs@sansano.usm.cl}). En caso de cualquier de modificaciones, todas se informarán tanto por aula como por discord.
    \item Todo lo necesario para realizar la tarea se encuentra en la \textbf{rama main} del repositorio de github:
\begin{center}

    \url{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main}
        
\end{center}
\item En el repositorio del punto (2) pueden existir otras ramas, pero main siempre será donde se encuentra la información oficial.
\end{enumerate}

\subsection{Descripción del Problema: Encontrando diferencias entre 2 secuencias}
\subsubsection{Encontrando Diferencias entre dos Secuencias}

Se quiere implementar una herramienta que permita mostrar todas las diferencias que existen entre dos secuencias de texto. En particular, dadas dos secuencias de caracteres $s[1{..}n]$ y $t[1{..}m]$, se deben mostrar pares de substrings en que difieren $s$ y $t$ (cada par debe tener un substring de $s$  y otro de $t$)\footnote{Note que el string vacío $\epsilon$ también es válido como substring}. En particular, para que esto sea útil para el usuario, se debe mostrar \textbf{la mínima cantidad de pares de substrings} que indiquen todas las diferencias entre $s$ y $t$. 

\medskip

\noindent
\emph{Hint}: para definir los pares de substrings a mostrar, se debe encontrar una serie de caracteres que aparezcan en ambas secuencias de entrada ($s$ y $t$). Esos caracteres particionan a $s$ y $t$ en substrings correspondientes que difieren, los cuales deben mostrarse. El problema es encontrar dichos caracteres de tal manera de minimizar la cantidad de pares a mostrar.



\subsubsection{Formato de Entrada}

La entrada de datos será por la entrada estándar (\texttt{stdin}), y contendrá varios casos de prueba. La primera línea de la entrada contiene un entero $K$ indicando la cantidad de casos a probar ($1 \le K \le 10.000.000$).
Luego, le siguen los $K$ casos, cada uno con el siguiente formato.
La primera línea comienza con un entero $n$, y es seguido por una secuencia $s$ de $n$ caracteres. Ambos datos están separados por un único espacio en la entrada. Puede asumir $1 \le n \le 1.000.000$.
La segunda línea del caso comienza con un entero $m$, y es seguido por una secuencia $t$ de $m$ caracteres. Ambos datos están separados por un único espacio en la entrada. Puede asumir $1 \le m \le 1.000.000$.

Un ejemplo de entrada es el siguiente:
\begin{verbatim}
3
6 ABCLGH 
6 AELFHR
6 AGGJAB
7 GZJZAMB
16 Este es un texto 
18 Este es otro texto
\end{verbatim}

\noindent
\textit{Hint}: para probar su programa de una mejor manera, ingrese los datos de entrada
con el formato indicado en un archivo de texto (por ejemplo, el archivo \texttt{input-1.dat}).
Luego, ejecute su programa desde la terminal, redirigiendo la entrada estándar como a continuación: 
\begin{verbatim}
./problema1 < input-1.dat
\end{verbatim}
De esta manera, evitará tener que entrar los datos manualmente cada vez que prueba su programa.





\subsubsection{Formato de Salida}

La salida se hará por la salida estándar (\texttt{stdout}). La salida comienza con el valor $K$, indicando la cantidad de casos de prueba (es el mismo valor $K$ de la entrada). Luego, para cada uno de los casos de prueba de la entrada, deben imprimirse todos los pares de substrings que difieren en las secuencias de entrada. El formato a usar es el siguiente. Si la cantidad de pares a mostrar para un caso es $L$, se debe imprimir el valor $L$, y a continuación se deben mostrar $L$ líneas, cada una conteniendo el correspondiente par de strings, separados por un único espacio. Sólo se deben mostrar los substrings que difieren en ambas secuencias. Los substrings mostrados pueden ser vacíos, aunque sólo tiene sentido mostrar los pares en los que al menos unos de los substrings no es vacío.

La salida correspondiente al ejemplo mostrado anteriormente es:
\begin{verbatim}
3
3
BC E
G F
 R
4
A 
G Z
 Z
 M
1
un otro
\end{verbatim} 
Note que en la tercera línea del primer caso, el substring correspondiente a la primera secuencia es vacío. Algo similar ocurre en la primera línea del segundo caso, en donde el substring correspondiente a la segunda secuencia es vacía.

\subsection{Implementaciones} \label{subsec:implementations}




\begin{enumerate}[(1)]
    \item Implementar cada uno los algoritmos en C++:
    \begin{itemize}
        \item Para el paradigma de fuerza bruta, se deben implementar en C++, en el archivo correspondiente, el algoritmo para encontrar diferencias entre dos secuencias.
    \begin{itemize}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/brute_force/algorithm/sequence_difference.cpp}{code/brute\_force/algorithm/sequence\_difference.cpp}
    \end{itemize}
        \item Para el paradigma de pogramación dinámica, se deben implementar en C++, en los archivos correspondientes, el algoritmo para encontrar diferencias entre dos secuencias.
    \begin{itemize}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/dynamic_programming/algorithm/sequence_difference.cpp}{code/dynamic\_programming/algorithm/sequence\_difference.cpp}
    \end{itemize}
    \end{itemize}

    \item Implementar el programa que realizará las mediciones de tiempo y memoria en C++ (programas principales) y su respectivo \texttt{makefile}, que ejecutará los algoritmos y generará los archivos de salida en cada uno de los directorios \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/brute_force/data/measurements}{measurements brute force} y \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/dynamic_programming/data/measurements}{measurements dynamic programming} con los resultados de cada uno de los algoritmos.
    \begin{itemize}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/brute_force/brute_force.cpp}{code/brute\_force/brute\_force.cpp}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/dynamic_programming/dynamic_programming.cpp}{code/dynamic\_programming/dynamic\_programming.cpp}
    \end{itemize}

    \item Implementar el programa que generará los inputs que se utilizarán en los algoritmos de ambos paradigmas y que dichos inputs seran guardados en las carpetas \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/brute_force/data/brute_force_input}{brute\_force\_input} y \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/dynamic_programming/scripts/input_generator.py}{dynamic\_programming\_input}. 
    \begin{itemize}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/brute_force/scripts/input_generator.py}{code/brute\_force/scripts/input\_generator.py}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/dynamic_programming/scripts/input_generator.py}{code/dynamic\_programming/scripts/input\_generator.py}
    \end{itemize}
    
    \item Implementar el programa que generará los gráficos en PYTHON y que se encargará de leer los archivos generados por los programas principales guardados en  \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/brute_force/data/measurements/}{measurements brute force} y \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/dynamic_programming/data/measurements}{measurements dynamic programming}, para luego graficar los resultados obtenidos y guardarlos en formato PNG en  \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/brute_force/data/plots}{plots brute force} y \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/code/dynamic_programming/data/plots}{plots dynamic programming}.
    \begin{itemize}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/brute_force/scripts/plot_generator.py}{code/brute\_force/scripts/plot\_generator.py}
        \item \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/blob/main/code/dynamic_programming/scripts/plot_generator.py}{code/dynamic\_programming/scripts/plot\_generator.py}
    \end{itemize}
    \item Documentar Cada uno de los pasos anteriores
    \begin{itemize}
        \item Completar el archivo \texttt{README.md} del directorio \texttt{code}
        \item Documentar en cada uno de sus programas, al inicio de cada archivo, fuentes de información, referencias y/o bibliografía utilizada para la implementación de cada uno de los algoritmos.
    \end{itemize}
\end{enumerate}

\subsection{Informe} \label{subsec:report}

Luego de realizar las implementaciones y experimentos, se debe generar un informe en \LaTeX\ que contenga los resultados obtenidos y una discusión sobre ellos. En el siguiente repositorio podrá encontrar el \href{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/report}{Template} que \textbf{deben utilizar}, en esta entrega:

\begin{mdframed}

\begin{center}
    
    \url{https://github.com/ianCooperA/INF221-2025-1-TAREA-2-3/tree/main/report}
        
\end{center}
\end{mdframed}

\begin{itemize}
    \item No se debe modificar la estructura del informe.
    \item Las indicaciones se encuentran en el archivo \texttt{README.md} del repositorio y en la plantilla de \LaTeX. 
\end{itemize}

