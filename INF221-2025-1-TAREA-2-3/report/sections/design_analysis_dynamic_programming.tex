\subsubsection{Descripción de la solución recursiva}
La soluci\'on con programaci\'on din\'amica implementa el cl\'asico algoritmo para encontrar la LCS utilizando una matriz de subproblemas. Primero se construye la tabla de DP, y luego se reconstruye la LCS desde dicha tabla. A partir de ella, se identifican los segmentos diferentes entre las secuencias.

La soluci\'on original al problema puede modelarse recursivamente considerando que si los \'{u}ltimos caracteres de $s$ y $t$ coinciden, entonces se incluye ese car\'acter en la LCS y se reduce el problema a los prefijos anteriores. En caso contrario, se toma el m\'aximo entre los resultados al omitir un car\'acter de una de las secuencias.

\subsubsection{Relación de recurrencia}
\begin{itemize}
  \item Caso base: Si $i = 0$ o $j = 0$, entonces $LCS(i, j) = 0$.
  \item Si $s[i-1] = t[j-1]$, entonces $LCS(i, j) = 1 + LCS(i-1, j-1)$.
  \item Si $s[i-1] \neq t[j-1]$, entonces $LCS(i, j) = \max(LCS(i-1, j), LCS(i, j-1))$.
\end{itemize}

\subsubsection{Identificación de subproblemas}
Los subproblemas est\'an definidos por los pares de \'{\i}ndices $(i, j)$ que representan los prefijos $s[0..i-1]$ y $t[0..j-1]$ de las cadenas de entrada. Se resuelven y almacenan en la tabla DP para evitar repeticiones.

\subsubsection{Estructura de datos y orden de cálculo}

Se utiliza una matriz bidimensional \texttt{dp} de tama\~no $(n+1) \times (m+1)$ donde $dp[i][j]$ almacena la longitud de la LCS entre los prefijos $s[0..i-1]$ y $t[0..j-1]$. El c\'alculo se realiza en orden ascendente (de menor a mayor), llenando fila por fila desde $dp[0][0]$ hasta $dp[n][m]$.

\subsubsection{Algoritmo utilizando programación dinámica}

\begin{algorithm}[H]
\SetAlgoLined
\KwIn{Secuencias $s$, $t$}
\KwOut{Lista de diferencias entre $s$ y $t$}
Crear matriz $dp$ de dimensiones $(n+1) \times (m+1)$ inicializada en 0\;
\For{$i \leftarrow 1$ \KwTo $n$}{
  \For{$j \leftarrow 1$ \KwTo $m$}{
    \If{$s[i-1] = t[j-1]$}{
      $dp[i][j] \leftarrow dp[i-1][j-1] + 1$\;
    }
    \Else{
      $dp[i][j] \leftarrow \max(dp[i-1][j], dp[i][j-1])$\;
    }
  }
}
Reconstruir LCS desde matriz $dp$\;
Usar LCS para segmentar las diferencias\;
\Return lista de diferencias
\caption{Algoritmo con programaci\'on din\'amica para diferencias de secuencias}
\end{algorithm}

\subsubsection*{Complejidad}
\begin{itemize}
  \item Tiempo: \( O(n \cdot m) \), al llenar la tabla de DP y reconstruir la LCS.
  \item Espacio: \( O(n \cdot m) \) por la matriz DP.
\end{itemize}

\subsection*{Resumen Comparativo}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Caracter\'istica} & \textbf{Fuerza Bruta} & \textbf{Programaci\'on Din\'amica} \\
\hline
Estrategia & Enumeraci\'on completa & Subproblemas + memoizaci\'on \\
\hline
Complejidad temporal & $O(2^n \cdot m)$ & $O(n \cdot m)$ \\
\hline
Complejidad espacial & $O(n + m)$ & $O(n \cdot m)$ \\
\hline
Ventaja & Simple para $n$ peque\~no & Escalable para entradas grandes \\
\hline
Desventaja & Inviable para $n > 20$ & Requiere m\'as memoria \\
\hline
\end{tabular}
\caption{Comparaci\'on general entre los algoritmos dise\~nados}
\end{table}
