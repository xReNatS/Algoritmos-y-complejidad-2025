En el ámbito de la Ciencias de la Computación, el diseño y análisis de algoritmos constituye una pieza fundamental para resolver problemas de manera eficiente. Tradicionalmente, la complejidad de un algoritmo se describe mediante notación asintótica, la cual ofrece una aproximación teórica sobre su comportamiento cuando el tamaño de los datos crece. Sin embargo, esta perspectiva no siempre refleja el rendimiento real al implementarse en computadoras modernas, donde factores como la arquitectura del procesador, la gestión de memoria y la distribución de datos afectan significativamente los tiempos de ejecución.

En este informe abordamos un estudio experimental de dos problemas clásicos: el ordenamiento de un arreglo unidimensional de números enteros y la multiplicación de matrices cuadradas. Para el primero, se comparan cuatro métodos de ordenamiento: Selection Sort, Merge Sort, Quick Sort y el algoritmo \texttt{std::sort} de la biblioteca estándar de C++ (cabe destacar que se utilizó una versión optimizada de QuickSort que utiliza InsertionSort, puesto que al intentar correrlo para vectores de 10 eleveado a 7 elementos se caia producto de la memoria stack utilizada). Para el segundo, se evalúan la multiplicación ingenua (Naive) y el método de Strassen. El propósito de este análisis es medir y contrastar el desempeño de cada algoritmo, relacionando los resultados empíricos con sus complejidades teóricas conocidas.

Los objetivos específicos de este trabajo son: (1) implementar los algoritmos mencionados en C++ y generar rendimiento de tiempo y consumo de memoria; (2) automatizar la recolección de datos y la creación de gráficos en Python para facilitar la reproducibilidad; y (3) discutir cómo las diferencias en la infraestructura y en las características de los datos de entrada influyen en el comportamiento práctico de los algoritmos. De este modo, se pretende ofrecer una visión más realista de su eficiencia y orientar la escogencia de métodos adecuados según el contexto de uso.

Todas las mediciones se realizaron en una misma plataforma, detallada en la sección de Experimentos, y utilizando conjuntos de datos generados con las herramientas provistas en el enunciado de la tarea. Con esta aproximación, esperamos entender mejor las ventajas y limitaciones de cada algoritmo, así como validar en la práctica las predicciones proporcionadas por la teoría de la complejidad.




