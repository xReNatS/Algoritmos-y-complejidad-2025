En este estudio experimental hemos comparado dos algoritmos de multiplicación de matrices (Naive y Strassen) y cuatro de ordenamiento (SelectionSort, MergeSort, QuickSort y \texttt{std::sort}), analizando su rendimiento en tiempo y memoria bajo distintas condiciones de entrada.

Para \textbf{multiplicación de matrices}, Strassen demostró su superioridad asintótica al reducir el tiempo de ejecución en dimensiones grandes (\(n\ge 2^8\)), a costa de un mayor consumo de memoria por las estructuras intermedias necesarias para la recursión. En matrices dispersas, el beneficio persiste, aunque el overhead inicial amortiza menos la ganancia en casos pequeños. De ello concluimos que Strassen es preferible cuando la memoria no es un recurso crítico y \(n\) es suficientemente grande.

En los \textbf{algoritmos de ordenamiento}, \texttt{std::sort} resultó el más eficiente, aprovechando híbridos de Quicksort e introspección para evitar los peores casos. MergeSort ofrece un rendimiento estable, con un costo de memoria adicional moderado, mientras que QuickSort puro es muy rápido en entradas aleatorias, pero puede degradarse en casos ordenados si no se aplica aleatorización del pivote. SelectionSort, debido a su complejidad cuadrática y bajo uso de memoria, solo es viable para vectores pequeños.

En conjunto, los resultados confirman las expectativas teóricas: algoritmos con mejor cota asintótica (Strassen, QuickSort, MergeSort) superan a los de orden cuadrático o cúbico en instancias grandes, aunque su implementación práctica debe equilibrar el consumo de memoria y el overhead de gestión de datos. Finalmente, este análisis refuerza la importancia de combinar estudios teóricos con mediciones experimentales para elegir la solución adecuada según las restricciones de cada problema.  
